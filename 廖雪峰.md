### 1，Git是目前世界上最先进的分布式版本控制系统。CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase. 
>* 集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。最大的毛病就是必须联网才能工作.
>* 分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。
>* 这两个工具主要的区别在于历史版本维护的位置, Git本地仓库包含代码库还有历史库，在本地的环境开发就可以记录历史;而SVN的历史库存在于中央仓库，每次对比与提交代码都必须连接到中央仓库才能进行。这样的好处在于：
1、自己可以在脱机环境查看开发的版本历史
2、多人开发时如果充当中央仓库的Git仓库挂了，任何一个开发者的仓库都可以作为中央仓库进行服务
>* **注意**：所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等；而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。**word**也是二进制文件。

### 2，开始菜单里找到“Git”->“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！然后设置：
>* $ git config --global user.name "Your Name"
>* $ git config --global user.email "email@example.com"

--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置

### 3，详细步骤
#### 1, 创建一个版本库，首先，选择一个合适的地方，创建一个空目录，如果有相对应的目录，则直接下面一步：
>* git init

此时可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。如果你没有看到.git目录，那是因为这个目录**默认是隐藏**的，用**ls -ah**命令就可以看见。

>* git add XX.文件名 # 把文件添加到仓库，**可反复多次使用，添加多个文件**
>* git commit -m "随便写，最好有意义" # 把文件提交到仓库

#### 2, 然后再修改文件，修改后可以**运行git status命令可以让我们时刻掌握仓库当前的状态**。
```
$ git status
On branch master
Changes not staged for commit: # readme.txt被修改过了，但还没有准备提交的修改。
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   readme.txt

no changes added to commit (use "git add" and/or "git commit -a")
```
#### 3, 如果记不清上次怎么修改的文件，可以用**git diff这个命令,顾名思义查看difference，显示的格式正是Unix通用的diff格式**：
```
$ git diff readme.txt 
diff --git a/readme.txt b/readme.txt
index 46d49bf..9247db6 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1,2 +1,2 @@
-Git is a version control system.
+Git is a distributed version control system. #
 Git is free software.
```
然后git add，此时状态是：
```
$ git status
On branch master
Changes to be committed: # 告诉我们，将要被提交的修改包括readme.txt
  (use "git reset HEAD <file>..." to unstage)

    modified:   readme.txt
```
然后再commit，此时状态是：
```
$ git status
On branch master
nothing to commit, working tree clean
```
#### 4，实际工作中，不可能记得文件每次都改了什么内容，在Git中，我们用git log命令查看我们的历史记录，显示从最近到最远的提交日志：
```
Author: zhangduo <774290360@qq.com>
Date:   Sun Sep 9 23:57:36 2018 +0900

    2 # 这里的就是改动，其实指的是-m 后面的内容，所以要写的好一些。

commit e0b53c3cc977b63533ff947a780298ad5fc383e3
Author: zhangduo <774290360@qq.com>
Date:   Sun Sep 9 23:56:45 2018 +0900

    1
```
如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：
```
$ git log --pretty=oneline #--oneline 和 --pretty=oneline 都能发挥log，没有pretty的是，只有commit id 前7位，加pretty的是全部的id
1aa72ab40da08af1cc11ed31fa9d16f5b61ca877 (HEAD -> master) 2 # 前面一串的是commit id（版本号）
e0b53c3cc977b63533ff947a780298ad5fc383e3 1
```
#### 5，把文件回退到上一个版本，也就是1的那个版本，怎么做呢？
在Git中，**用HEAD表示当前版本**，也就是最新的提交1aa72ab40d...上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。

现在，我们要把当前版本2回退到上一个版本1，就可以使用git reset命令：
```
$ git reset --hard head^ # 注意是--hard 
HEAD is now at e0b53c3 1
```
但又想回去怎么办，找到那个2的commit id是1aa72ab40da...，于是就可以指定回到未来的某个版本：
```
$ git reset --hard 1aa72  # 版本号没必要写全，前几位就可以了，Git会自动去找。
HEAD is now at  1aa72ab 2 
```
目前是已知commit id,但找不到新版本的commit id怎么办？ Git提供了一个命令**git reflog用来记录你的每一次命令**：
```
$ git reflog # 这个顺序应该是从下到上，也就是head3到head0（即当前状态）
1aa72ab (HEAD -> master) HEAD@{0}: reset: moving to 1aa72
e0b53c3 HEAD@{1}: reset: moving to head^
1aa72ab (HEAD -> master) HEAD@{2}: commit: 2 # 由此可知，2的commit id是1aa72ab
e0b53c3 HEAD@{3}: commit (initial): 1 
```
**总结**：
```
HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。

穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。

要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。
```
